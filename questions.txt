-o formato das messages é suficiente para nunca se perder mensagens nenhumas?
-forma como o tcp se liga ao rmi é suficiente? falha momentânea do rmi server é capaz de dar bode
-ter em atenção o que acontece quando um cliente está a meio de alguma acção e recebe um invite para uma meeting
-mostrar users online!!! realizado com hashmap!! extra points
-backup server still stupid
-garantir que quando um utilizador está ligado ao server de backup, com os dois servers up, e o server de backup cai, quando se voltar a tentar ligar a um
dos servers, que comece do server de backup e so depois tenta o outro
-voltar a ver a cena dos pings/subscribe do rmi-tcp. Segundo a checklist, não parece ser ncessário.
-ponderar a colocação de attachments nas meettings (o código tá feito do ano passado para a colocação de imagens)
-uma vez que, no cliente, estou-me a tentar ligar a dois sockets (por causa das diferents threads), no tcpserver, tenho de criar duas
connections/duas formas de ele aceitar a tal ligação que o cliente está a tentar fazer, certo?
-tem que se implementar lógica de: primary e backup vivos, clientes que já estavam ligados, ligam-se ao backup. E os novos? Se entretanto
o primary volta toma o lugar de backup e tem de haver uma lógica que obrigue o cliente a ligar-se ao outro e vice-versa. Possivelmente só depois de implementar a cena dos pings.

-java code standards? wtf?
-configuration does not need recompilation?
-For the defense, slow down the RMI Server by adding a Thread.sleep(2000) at
the beginning and another one at the end of two methods: createNewMeeting() and postNewDiscussionMessage().
Vão querer rebentar com o quê?...

